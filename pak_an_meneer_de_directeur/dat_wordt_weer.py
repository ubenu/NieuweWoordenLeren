'''
Created on 22 Oct 2017

@author: marietje
'''

from PyQt5 import QtCore as qt
from PyQt5 import QtWidgets as widgets

import pandas as pd, numpy as np


from PyQt5.uic import loadUiType
Ui_MainWindow, QMainWindow = loadUiType('..\\Resources\\UI\\nwl.ui')

# Original:
# To avoid using .ui file (from QtDesigner) and loadUIType, 
# created a python-version of the .ui file using pyuic5 from command line
# Here: pyuic5 blits.ui -o blits_ui.py
# Also: cannot (easily) use .qrc file, so need to create _rc.py file
# with icon definitions: pyrcc5 -o blits_rc.py blits.qrc
# Then import .py package, as below.
# (QMainWindow is a QtWidget; UI_MainWindow is generated by the converted .ui)

class Main(QMainWindow, Ui_MainWindow):
    heaps = ['Nieuw', 
             'Gezien', 
             'Zilver', 
             'Goud', 
             'Platina',
             ]
    stakes = ['Zilver', 
              'Goud', 
              'Platina', 
              ]
    articles = ['De', 
                'Het', 
                ]
    states = ['start', 
              'words set', 
              'scoring set', 
              'ready', 
              'none selected', 
              'article selected', 
              'stake selected',  
              'all selected', 
              'played',
              'finished',
              ]
    answers = ['fout', 
               'goed',
               ]
    n_minimum_words_in_current_list = 20
                   
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        
        self.tbl_heaps.verticalHeader().setSectionResizeMode(3)
        
        self.action_open_word_list.triggered.connect(self.on_open_word_list)
        self.action_open_scoring.triggered.connect(self.on_open_scoring)
        self.action_add_new_words.triggered.connect(self.on_add_new_words)
        self.action_draw.triggered.connect(self.on_draw)
        self.action_play.triggered.connect(self.on_play)
        self.action_stop_and_save.triggered.connect(self.on_stop_and_save)
        self.btn_stop_and_save.setDefaultAction(self.action_stop_and_save)
        self.btn_draw.setDefaultAction(self.action_draw)
        self.btn_play.setDefaultAction(self.action_play)
        i = 0
        for chk in self.grp_article.findChildren(widgets.QCheckBox):
            chk.setText(self.articles[i])
            chk.clicked.connect(self.on_article_clicked)
            i += 1
        i = 0
        for chk in self.grp_stake.findChildren(widgets.QCheckBox):
            chk.setText(self.stakes[i])
            chk.clicked.connect(self.on_stake_clicked)
            i += 1

        self.file_name_word_list = None
        self.file_name_scoring = None
        self.full_word_list = None
        self.scoring_info = None
        self.words_in_heaps = {}
        for heap in self.heaps:
            self.words_in_heaps[heap] = None

        self.current_word_entry = None
        self.current_word_list = None
        self.current_heap = ''
        self.current_word = ''
        self.current_new_word = ''
        self.answer_correct = False
        self.selected_article = ''
        self.selected_stake = ''
        self.points_if_correct = ''
        self.points_if_incorrect = ''
        self.available_stakes = []
        self.score = 0
        self.selected_stake = self.stakes[0]
        
        self.current_state = 'start'
        self.update_game()
        self.update_ui()
        self.import_word_list('..\\Resources\\Input\\Woordenlijst.csv')
        self.import_scoring('..\\Resources\\Input\\Puntentelling.csv')
        
        self.current_state = 'ready'
        self.update_game()
        self.update_ui()
        

    def on_open_word_list(self):
        file_path = widgets.QFileDialog.getOpenFileName(self, 
        "Open woordenlijst", "", "CSV data files (*.csv);;All files (*.*)")[0]
        if file_path:
            info = qt.QFileInfo(file_path)
            self.file_name_word_list = info.fileName()
            self.import_word_list(file_path)
            if self.current_state == self.states.index('scoring set'):
                self.current_state = self.states.index('ready')
            else:
                self.current_state = self.states.index('words set')
            self.update_game()
            self.update_ui()

    def on_open_scoring(self):
        file_path = widgets.QFileDialog.getOpenFileName(self, 
        "Open puntentelling", "", "CSV data files (*.csv);;All files (*.*)")[0]
        if file_path:
            info = qt.QFileInfo(file_path)
            self.file_name_scoring = info.fileName()
            self.import_scoring(file_path)
            if self.current_state == self.states.index('words set'):
                self.current_state = self.states.index('ready') 
            else:  
                self.current_state = self.states.index('scoring set')
            self.update_game()
            self.update_ui()

    def on_add_new_words(self):
        file_path = widgets.QFileDialog.getOpenFileName(self, 
        "Open woordenlijst", "", "CSV data files (*.csv);;All files (*.*)")[0]
        if file_path:
            self.all_words_info = pd.read_csv(file_path, encoding='UTF-16', header=None, na_filter=False)
            print(self.all_words_info) #.as_matrix() #encoding='iso8859_6'
            self.current_state = 'adding new'
            self.update_game()
            self.update_ui()
            
    def on_stop_and_save(self):
        pass
            
    def on_draw(self):
        if self.current_state == 'adding_new':
            self.current_new_word = self.all_words_info.iloc[0,0]
        else:
            self.current_word_entry = self.current_word_list.sample()
            self.current_state = 'none selected'
        self.update_game()
        self.update_ui()
        
    def on_play(self):
        if self.current_state != 'adding_new':            
            self.current_state = 'played'
            self.update_game()
            self.update_ui()
        
    def on_article_clicked(self):
        cx1 = self.sender() 
        cxs = self.grp_article.findChildren(widgets.QCheckBox)
        for cx in cxs:
            if not cx.isChecked() and cx is cx1:
                cx.setChecked(True)
            elif cx.isChecked() and cx is not cx1:
                cx.setChecked(False)
        if self.current_state in ('stake selected', 'all selected'):
            self.current_state = 'all selected'
        elif self.current_state in ('none selected', 'article selected'):
            self.current_state = 'article selected'
        else:
            print('Forbidden transition from ' + self.current_state)        
        self.update_game()
        self.update_ui()
            
    def on_stake_clicked(self):
        cx1 = self.sender() 
        cxs = self.grp_stake.findChildren(widgets.QCheckBox)
        for cx in cxs:
            if not cx.isChecked() and cx is cx1:
                cx.setChecked(True)
            elif cx.isChecked() and cx is not cx1:
                cx.setChecked(False)
        if self.current_state in ('article selected', 'all selected'):
            self.current_state = 'all selected'
        elif self.current_state in ('none selected', 'stake selected'):
            self.current_state = 'stake selected'
        else:
            print('Forbidden transition from ' + self.current_state)
        self.update_game()
        self.update_ui()   
                          
    def import_word_list(self, file_path):
        self.full_word_list = pd.read_csv(file_path)
        status = self.full_word_list['Stapel']
        self.words_in_heaps = {}
        for heap in self.heaps:
            self.words_in_heaps[heap] = self.full_word_list[status == heap]
        self.current_word_list = self.words_in_heaps[self.heaps[1]]
        for lvl in self.heaps[2:len(self.heaps)]:
            self.current_word_list = self.current_word_list.append(self.words_in_heaps[lvl])
        n_new = min(len(self.words_in_heaps[self.heaps[0]]), len(self.words_in_heaps[self.heaps[3]]))
        new_words = self.words_in_heaps[self.heaps[0]].sample(n=n_new)
        self.current_word_list = self.current_word_list.append(new_words).sort_index()
  


    def import_scoring(self, file_path):
        self.scoring_info = pd.read_csv(file_path)
        #print(self.scoring_info)

        

    def update_game(self):
        """
        states = ['start', 
                  'words set', 
                  'scoring set', 
                  'ready', 
                  'none selected', 
                  'article selected', 
                  'stake selected',  
                  'all selected', 
                  'played',
                  'finished',
                  ]
        """
        if self.current_state == 'start':
            pass
        if self.current_state == 'words set':
            pass
        if self.current_state == 'scoring set':
            pass       
        if self.current_state == 'ready':
            pass
        if self.current_state == 'none selected':
            self.current_word = self.current_word_entry.Woord.iloc[0]
            self.current_article = self.current_word_entry.Lidwoord.iloc[0]
            self.current_heap = self.current_word_entry.Stapel.iloc[0]
            self.available_stakes = self.scoring_info[self.scoring_info.Stapel == self.current_heap].Inzet.unique()
            self.selected_article = ''
            self.selected_stake = ''
            
        if self.current_state in ('article selected', ):
            for cx in self.grp_article.findChildren(widgets.QCheckBox):
                if cx.isChecked(): # only one may be checked
                    self.selected_article = cx.text()
        
        if self.current_state in ('stake selected', ):
            for cx in self.grp_stake.findChildren(widgets.QCheckBox):
                if cx.isChecked(): # only one may be checked
                    self.selected_stake = cx.text()
            self.set_prospective_score()
                
        if self.current_state == 'all selected':
            # next should already have been set, but just in case...
            for cx in self.grp_article.findChildren(widgets.QCheckBox):
                if cx.isChecked(): # only one may be checked
                    self.selected_article = cx.text()
            for cx in self.grp_stake.findChildren(widgets.QCheckBox):
                if cx.isChecked(): # only one may be checked
                    self.selected_stake = cx.text()
            self.set_prospective_score()

        if self.current_state == 'played':
            self.answer_correct = False
            if self.selected_article.lower() == self.current_article.lower():
                self.answer_correct = True
            if self.answer_correct:
                self.score += int(self.points_if_correct)
                self.current_word_entry.Stapel = self.next_heap_if_correct
            else:
                self.score += int(self.points_if_incorrect)
                self.current_word_entry.Stapel = self.next_heap_if_incorrect
            self.current_word_list.loc[self.current_word_entry.index] = self.current_word_entry
            self.available_stakes = []
           
        if self.current_state == 'finished':
            pass   
        
        if self.current_state == 'adding new':
            print(self.current_state)  
            print(self.all_words_info)
        
    def update_ui(self):
        """
        states = ['start', 
                  'words set', 
                  'scoring set', 
                  'ready', 
                  'none selected', 
                  'article selected', 
                  'stake selected',  
                  'all selected', 
                  'played',
                  'finished',
                  'adding new',
                  ]
        """
        tally = self.get_word_status_tally()
        for level in self.heaps:
            i = self.tbl_heaps.item(self.heaps.index(level), 0)
            i.setText('{:d}'.format(int(tally[level])))
            
        if self.current_state in ('start', 'words set', 'scoring set'):
            self.btn_draw.setEnabled(False)
            self.btn_play.setEnabled(False)
            self.txt_word.setEnabled(False)
            self.txt_word.setText(self.current_word)
            for chk in self.grp_article.findChildren(widgets.QCheckBox):
                chk.setChecked(False)
                chk.setEnabled(False)
            for chk in self.grp_stake.findChildren(widgets.QCheckBox):
                chk.setChecked(False)
                chk.setEnabled(False)
            for i in range(self.tbl_word_score.rowCount()):
                self.tbl_word_score.item(i, 0).setCheckState(qt.Qt.Unchecked)
            self.txt_state.setText("Stapel:  " + self.current_heap)
            
        if self.current_state == 'ready':
            self.btn_draw.setEnabled(True)
            self.btn_play.setEnabled(False)
            self.txt_word.setEnabled(False)
            
        if self.current_state == 'none selected':
            self.btn_draw.setEnabled(False)
            self.txt_word.setEnabled(True)
            self.txt_word.setText(self.current_word)
            for chk in self.grp_article.findChildren(widgets.QCheckBox):
                chk.setChecked(False)
                chk.setEnabled(True)
            for chk in self.grp_stake.findChildren(widgets.QCheckBox):
                chk.setChecked(False)
                chk.setEnabled(False)
                stake = chk.text()
                if stake in self.available_stakes:
                    chk.setEnabled(True)
            for i in range(self.tbl_word_score.rowCount()):
                self.tbl_word_score.item(i, 0).setCheckState(qt.Qt.Unchecked)
            self.txt_state.setText("Stapel:  " + self.current_heap)
            
        if self.current_state == 'article selected':
            pass
        
        if self.current_state in ('stake selected', 'all selected'):
            self.tbl_word_score.item(0, 0).setText(self.points_if_correct)
            self.tbl_word_score.item(1, 0).setText(self.points_if_incorrect)
            
        if self.current_state == 'all selected':
            self.btn_play.setEnabled(True)
            
        if self.current_state == 'played':
            for chk in self.grp_article.findChildren(widgets.QCheckBox):
                chk.setEnabled(False)
            for chk in self.grp_stake.findChildren(widgets.QCheckBox):
                chk.setEnabled(False)
            self.btn_draw.setEnabled(True)
            self.btn_play.setEnabled(False)
            self.txt_word.setEnabled(True)
            self.txt_word.setText(self.current_article + " " + self.current_word)
            w_correct = self.tbl_word_score.item(0, 0)
            w_wrong = self.tbl_word_score.item(1, 0)
            w_correct.setCheckState(qt.Qt.Unchecked)
            w_wrong.setCheckState(qt.Qt.Unchecked)
            if self.answer_correct:
                w_correct.setCheckState(qt.Qt.Checked)
            else:
                w_wrong.setCheckState(qt.Qt.Checked)
            self.txt_total.setText('{0}'.format(self.score))
            
        if self.current_state == 'adding new':
            for chk in self.grp_article.findChildren(widgets.QCheckBox):
                chk.setEnabled(False)
            for chk in self.grp_stake.findChildren(widgets.QCheckBox):
                chk.setEnabled(False)
            self.btn_draw.setEnabled(True)
            self.btn_play.setEnabled(True)
            self.txt_word.setEnabled(True)            
            self.txt_word.setText(self.current_new_word)
    
    def get_word_status_tally(self):
        tally = pd.Series(index=self.heaps)
        for heap in self.heaps:
            tally[heap] = 0
            if not self.current_word_list is None:
                tally[heap] = len(self.current_word_list[self.current_word_list.Stapel == heap])
        return tally
    
    def set_prospective_score(self): 
        scoring_for_heap = self.scoring_info[self.scoring_info.Stapel == self.current_heap]
        scoring_for_stake = scoring_for_heap[scoring_for_heap.Inzet == self.selected_stake]
        self.points_if_correct = '{0}'.format(scoring_for_stake[scoring_for_stake.Antwoord == 'goed'].Punten.iloc[0])
        self.next_heap_if_correct = scoring_for_stake[scoring_for_stake.Antwoord == 'goed'].Bestemming.iloc[0]
        self.points_if_incorrect = '{0}'.format(scoring_for_stake[scoring_for_stake.Antwoord == 'fout'].Punten.iloc[0])
        self.next_heap_if_incorrect = scoring_for_stake[scoring_for_stake.Antwoord == 'fout'].Bestemming.iloc[0]

# Standard main loop code
if __name__ == '__main__':
    import sys
    app = widgets.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())
    
    
