'''
Created on 22 Oct 2017

@author: marietje
'''

from PyQt5 import QtCore as qt
from PyQt5 import QtWidgets as widgets

import pandas as pd


from PyQt5.uic import loadUiType
Ui_MainWindow, QMainWindow = loadUiType('..\\Resources\\UI\\nwl.ui')

# Original:
# To avoid using .ui file (from QtDesigner) and loadUIType, 
# created a python-version of the .ui file using pyuic5 from command line
# Here: pyuic5 blits.ui -o blits_ui.py
# Also: cannot (easily) use .qrc file, so need to create _rc.py file
# with icon definitions: pyrcc5 -o blits_rc.py blits.qrc
# Then import .py package, as below.
# (QMainWindow is a QtWidget; UI_MainWindow is generated by the converted .ui)

class Main(QMainWindow, Ui_MainWindow):
    heaps = ['Nieuw', 'Gezien', 'Zilver', 'Goud', 'Platina',]
    stake = ['Zilver', 'Goud', 'Platina']
    ui_states = ['start', 'word list set', 'scoring set', 'ready', 'word drawn', 'selecting', 'played']
    answers = ['fout', 'goed']
    n_minimum_words_in_current_list = 20
                   
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        
        self.tbl_heaps.verticalHeader().setSectionResizeMode(3)
        
        self.action_open_word_list.triggered.connect(self.on_open_word_list)
        self.action_open_scoring.triggered.connect(self.on_open_scoring)
        self.action_draw.triggered.connect(self.draw)
        self.action_play.triggered.connect(self.play)
        self.btn_draw.setDefaultAction(self.action_draw)
        self.btn_play.setDefaultAction(self.action_play)
        self.chk_de.stateChanged.connect(self.on_de_changed)
        self.chk_het.stateChanged.connect(self.on_het_changed)
        self.chk_zilver.stateChanged.connect(self.on_zilver_changed)
        self.chk_goud.stateChanged.connect(self.on_goud_changed)
        self.chk_platina.stateChanged.connect(self.on_platina_changed)

        self.file_name_word_list = None
        self.file_name_scoring = None
        self.full_word_list = None
        self.scoring = None
        self.current_word_entry = None
        self.current_word_list = None
        self.answer_correct = False
        self.words_in_heaps = {}
        for heap in self.heaps:
            self.words_in_heaps[heap] = None
        self.selected_article = ''
        self.selected_stake = ''
        self.points_if_correct = 0
        self.points_if_incorrect = 0
        self.available_stakes = []
        self.score = 0
        self.selected_stake = self.stake[0]
        self.ui_state = self.ui_states.index('start')
        self.import_word_list('..\\Resources\\Input\\Woordenlijst.csv')
        self.import_scoring('..\\Resources\\Input\\Puntentelling.csv')
        self.update_game()
        self.update_ui()

    def on_open_word_list(self):
        file_path = widgets.QFileDialog.getOpenFileName(self, 
        "Open woordenlijst", "", "CSV data files (*.csv);;All files (*.*)")[0]
        if file_path:
            info = qt.QFileInfo(file_path)
            self.file_name_word_list = info.fileName()
            self.import_word_list(file_path)
            self.update_game()
            self.update_ui()
            
    def import_word_list(self, file_path):
        self.full_word_list = pd.read_csv(file_path)
        status = self.full_word_list['Stapel']
        self.words_in_heaps = {}
        for heap in self.heaps:
            self.words_in_heaps[heap] = self.full_word_list[status == heap]
        self.current_word_list = self.words_in_heaps[self.heaps[1]]
        for lvl in self.heaps[2:len(self.heaps)]:
            self.current_word_list = self.current_word_list.append(self.words_in_heaps[lvl])
        n_new = min(len(self.words_in_heaps[self.heaps[0]]), len(self.words_in_heaps[self.heaps[3]]))
        new_words = self.words_in_heaps[self.heaps[0]].sample(n=n_new)
        self.current_word_list = self.current_word_list.append(new_words).sort_index()
        if self.ui_state == self.ui_states.index('scoring set'):
            self.ui_state = self.ui_states.index('ready')
        else:
            self.ui_state = self.ui_states.index('word list set')

    def on_open_scoring(self):
        file_path = widgets.QFileDialog.getOpenFileName(self, 
        "Open puntentelling", "", "CSV data files (*.csv);;All files (*.*)")[0]
        if file_path:
            info = qt.QFileInfo(file_path)
            self.file_name_scoring = info.fileName()
            self.import_scoring(file_path)
            self.update_game()
            self.update_ui()
                    
    def import_scoring(self, file_path):
        self.scoring = pd.read_csv(file_path)
        if self.ui_state == self.ui_states.index('word list set'):
            self.ui_state = self.ui_states.index('ready') 
        else:  
            self.ui_state = self.ui_states.index('scoring set')

    def get_word_status_tally(self):
        tally = pd.Series(index=self.heaps)
        for heap in self.heaps:
            tally[heap] = 0
            if not self.current_word_list is None:
                tally[heap] = len(self.current_word_list[self.current_word_list.Stapel == heap])
        return tally

    def draw(self):
        self.current_word_entry = self.current_word_list.sample()
        self.ui_state = self.ui_states.index('word drawn')
        self.update_game()
        self.update_ui()
        
    def play(self):
        self.ui_state = self.ui_states.index('played')
        self.update_game()
        self.update_ui()
        
    def update_game(self):
        if self.ui_states[self.ui_state] == 'start':
            pass
        if self.ui_states[self.ui_state] == 'word list set':
            pass
        if self.ui_states[self.ui_state] == 'scoring set':
            pass       
        if self.ui_states[self.ui_state] == 'ready':
            pass
        if self.ui_states[self.ui_state] == 'word drawn':
            self.current_word = self.current_word_entry.Woord.iloc[0]
            self.current_article = self.current_word_entry.Lidwoord.iloc[0]
            self.current_heap = self.current_word_entry.Stapel.iloc[0]
            scoring_for_heap = self.scoring[self.scoring.Stapel == self.current_heap]
            self.available_stakes = scoring_for_heap.Inzet.unique()
            
        if self.ui_states[self.ui_state] == 'played':
            self.answer_correct = False
            if self.selected_article.lower() == self.current_article.lower():
                self.answer_correct = True
            self.available_stakes = []
                    
        
    def update_ui(self):
        tally = self.get_word_status_tally()
        for level in self.heaps:
            i = self.tbl_heaps.item(self.heaps.index(level), 0)
            i.setText('{:d}'.format(int(tally[level])))
            for chk in self.grp_stake.findChildren(widgets.QCheckBox):
                chk.setEnabled(False)
                stake = chk.text()
                if stake in self.available_stakes:
                    chk.setEnabled(True)
            for chk in self.grp_article.findChildren(widgets.QCheckBox):
                chk.setEnabled(False)
            
        if self.ui_states[self.ui_state] in ('start', 'word list set', 'scoring set'):
            self.btn_draw.setEnabled(False)
            self.btn_play.setEnabled(False)
            self.txt_word.setEnabled(False)
            
        if self.ui_states[self.ui_state] == 'ready':
            self.btn_draw.setEnabled(True)
            self.btn_play.setEnabled(False)
            self.txt_word.setEnabled(False)
            
        if self.ui_states[self.ui_state] == 'word drawn':
            self.btn_draw.setEnabled(False)
            self.btn_play.setEnabled(True)
            self.txt_word.setEnabled(True)
            self.txt_word.setText(self.current_word)
            for chk in self.grp_article.findChildren(widgets.QCheckBox):
                chk.setChecked(qt.Qt.Unchecked)
                chk.setEnabled(True)
            for chk in self.grp_stake.findChildren(widgets.QCheckBox):
                chk.setChecked(qt.Qt.Unchecked)
            for i in range(self.tbl_word_score.rowCount()):
                self.tbl_word_score.item(i, 0).setCheckState(qt.Qt.Unchecked)
            self.txt_state.setText("Stapel:  " + self.current_heap)
            
        if self.ui_states[self.ui_state] == 'selecting':
            self.tbl_word_score.item(0, 0).setText('{0}'.format(self.points_if_correct))
            self.tbl_word_score.item(1, 0).setText('{0}'.format(self.points_if_incorrect))
            
        if self.ui_states[self.ui_state] == 'played':
            self.btn_draw.setEnabled(True)
            self.btn_play.setEnabled(False)
            self.txt_word.setEnabled(True)
            self.txt_word.setText(self.current_article + " " + self.current_word)
            w_correct = self.tbl_word_score.item(0, 0)
            w_wrong = self.tbl_word_score.item(1, 0)
            w_correct.setCheckState(qt.Qt.Unchecked)
            w_wrong.setCheckState(qt.Qt.Unchecked)
            if self.answer_correct:
                w_correct.setCheckState(qt.Qt.Checked)
            else:
                w_wrong.setCheckState(qt.Qt.Checked)
            
            
    def on_de_changed(self):
        self.selected_article = ''
        self.ui_state = self.ui_states.index('selecting')
        if self.chk_de.isChecked():
            self.chk_het.setChecked(qt.Qt.Unchecked)
            self.selected_article = 'de'
            
    def on_het_changed(self):
        self.selected_article = ''
        self.ui_state = self.ui_states.index('selecting')
        if self.chk_het.isChecked():
            self.chk_de.setChecked(qt.Qt.Unchecked)
            self.selected_article = 'het'
            
    def on_zilver_changed(self):
        self.selected_stake = ''
        self.ui_state = self.ui_states.index('selecting')
        self.points_if_correct = 0
        self.points_if_incorrect = 0
        if self.chk_zilver.isChecked():
            self.chk_goud.setChecked(qt.Qt.Unchecked)
            self.chk_platina.setChecked(qt.Qt.Unchecked)
            self.selected_stake = 'Zilver'
            self.set_prospective_score()
#        self.update_game()
        self.update_ui()
            
    def on_goud_changed(self):
        self.selected_stake = ''
        self.ui_state = self.ui_states.index('selecting')
        self.points_if_correct = 0
        self.points_if_incorrect = 0
        if self.chk_goud.isChecked():
            self.chk_zilver.setChecked(qt.Qt.Unchecked)
            self.chk_platina.setChecked(qt.Qt.Unchecked)
            self.selected_stake = 'Goud'
            self.set_prospective_score()
#        self.update_game()
        self.update_ui()
            
    def on_platina_changed(self):
        self.selected_stake = ''
        self.ui_state = self.ui_states.index('selecting')
        self.points_if_correct = 0
        self.points_if_incorrect = 0
        if self.chk_platina.isChecked():
            self.chk_zilver.setChecked(qt.Qt.Unchecked)
            self.chk_goud.setChecked(qt.Qt.Unchecked)
            self.selected_stake = 'Platina'
            self.set_prospective_score()
#        self.update_game()
        self.update_ui()
            
    def set_prospective_score(self): 
        if self.ui_states[self.ui_state] == 'selecting':
            scoring_for_heap = self.scoring[self.scoring.Stapel == self.current_heap]
            scoring_for_stake = scoring_for_heap[scoring_for_heap.Inzet == self.selected_stake]
            self.points_if_correct = scoring_for_stake[scoring_for_stake.Antwoord == 'goed'].Punten.iloc[0]
            self.points_if_incorrect = scoring_for_stake[scoring_for_stake.Antwoord == 'fout'].Punten.iloc[0]

# Standard main loop code
if __name__ == '__main__':
    import sys
    app = widgets.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())